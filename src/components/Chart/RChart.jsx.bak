import React from 'react';
import PropTypes from 'prop-types';
import Chart from 'chart.js';
import isEqual from 'lodash/isEqual';
import keyBy from 'lodash/keyBy';

const NODE_ENV = (typeof process !== 'undefined') && process.env && process.env.NODE_ENV;

class ChartComponent extends React.Component {

	static getLabelAsKey = d => d.label;

	componentDidMount() {
		this.renderChart();
	}

	componentWillUnmount() {
		this.destroyChart();
	}


	renderChart() {
		const {options, legend, type, plugins} = this.props;
		const node = this.element;
		const data = this.memoizeDataProps();

		if(typeof legend !== 'undefined' && !isEqual(ChartComponent.defaultProps.legend, legend)) {
			options.legend = legend;
		}

	}

	destroyChart() {
		if (!this.chartInstance) {
			return;
		}

		// Put all of the datasets that have existed in the chart back on the chart
		// so that the metadata associated with this chart get destroyed.
		// This allows the datasets to be used in another chart. This can happen,
		// for example, in a tabbed UI where the chart gets created each time the
		// tab gets switched to the chart and uses the same data).
		this.saveCurrentDatasets();
		const datasets = Object.values(this.datasets);
		this.chartInstance.config.data.datasets = datasets;

		this.chartInstance.destroy();
	}

	handleOnClick = (event) => {

	}

	ref = (element) => {
		this.element = element;
	}


}

